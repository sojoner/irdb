# Default values for irdb-postgres.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

image:
  repository: "sojoner/database"
  tag: "0.0.7"
  majorVersion: 17
  pullPolicy: IfNotPresent

# CloudNativePG Cluster configuration (passed to cnpg/cluster subchart as 'cluster' values)
cnpg:
  cluster:
    name: postgres
    instances: 3

    # Storage configuration
    storage:
      size: 10Gi
      storageClass: standard

    # Resource configuration
    resources:
      requests:
        memory: 2Gi
        cpu: 1000m
      limits:
        memory: 4Gi
        cpu: 2000m

    # PostgreSQL parameters for AI workloads
    postgresql:
      parameters:
        # Connection settings
        max_connections: "200"

        # Memory settings (optimized for AI/vector search)
        shared_buffers: "512MB"
        effective_cache_size: "1536MB"
        work_mem: "32MB"
        maintenance_work_mem: "512MB"

        # WAL settings
        wal_level: "logical"
        max_wal_size: "2GB"
        min_wal_size: "1GB"
        wal_buffers: "16MB"

        # Checkpoint settings
        checkpoint_timeout: "15min"
        checkpoint_completion_target: "0.9"

        # Query planner (optimized for SSD)
        random_page_cost: "1.1"
        effective_io_concurrency: "200"

        # Parallel query (for vector operations)
        max_parallel_workers: "4"
        max_parallel_workers_per_gather: "2"
        max_worker_processes: "8"

        # Logging
        log_min_duration_statement: "1000"
        log_checkpoints: "on"
        log_connections: "on"
        log_disconnections: "on"
        log_lock_waits: "on"

    # High availability settings
    minSyncReplicas: 1
    maxSyncReplicas: 2

    # Affinity for pod distribution
    affinity:
      enablePodAntiAffinity: true
      podAntiAffinityType: preferred

    # Database initialization via SQL scripts
    bootstrap:
      initdb:
        encoding: UTF8
        locale: C
        # Database name
        database: database
        # Owner user
        owner: postgres
        # Post-init SQL scripts executed after cluster bootstrap
        postInitApplicationSQL:
          - |
            CREATE EXTENSION IF NOT EXISTS vector;
            CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
            CREATE EXTENSION IF NOT EXISTS pg_trgm;
            CREATE EXTENSION IF NOT EXISTS btree_gin;
            CREATE EXTENSION IF NOT EXISTS pg_search;
          - |
            DO $$ BEGIN
                IF NOT EXISTS (SELECT FROM pg_user WHERE usename = 'app') THEN
                    CREATE ROLE app WITH LOGIN ENCRYPTED PASSWORD 'app_password_123';
                END IF;
            END $$;
          - |
            CREATE SCHEMA IF NOT EXISTS ai_data;
            GRANT ALL ON SCHEMA ai_data TO postgres;
            GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA ai_data TO postgres;
            GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA ai_data TO postgres;
          - |
            CREATE TABLE IF NOT EXISTS ai_data.documents (
                id SERIAL PRIMARY KEY,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                metadata JSONB,
                embedding vector(1536),
                created_at TIMESTAMP DEFAULT NOW(),
                updated_at TIMESTAMP DEFAULT NOW()
            );
          - |
            CREATE TABLE IF NOT EXISTS ai_data.chunks (
                id SERIAL PRIMARY KEY,
                document_id INTEGER REFERENCES ai_data.documents(id),
                chunk_text TEXT NOT NULL,
                chunk_index INTEGER,
                embedding vector(1536),
                token_count INTEGER,
                created_at TIMESTAMP DEFAULT NOW()
            );
          - |
            CREATE INDEX IF NOT EXISTS idx_documents_embedding ON ai_data.documents USING hnsw (embedding vector_cosine_ops);
            CREATE INDEX IF NOT EXISTS idx_chunks_embedding ON ai_data.chunks USING hnsw (embedding vector_cosine_ops);
            CREATE INDEX IF NOT EXISTS idx_documents_title_content ON ai_data.documents USING gin(to_tsvector('english', title || ' ' || content));
          - |
            CREATE OR REPLACE FUNCTION ai_data.generate_random_vector(dimensions INTEGER)
            RETURNS vector AS $$
            DECLARE
                result vector;
            BEGIN
                SELECT INTO result
                    (SELECT array_agg(random()) FROM generate_series(1, dimensions))::vector;
                RETURN result;
            END;
            $$ LANGUAGE plpgsql;
          - |
            CREATE OR REPLACE FUNCTION ai_data.hybrid_search(
                query_text TEXT,
                query_embedding vector(1536),
                similarity_threshold FLOAT DEFAULT 0.8,
                limit_count INTEGER DEFAULT 10
            )
            RETURNS TABLE (
                id INTEGER,
                title TEXT,
                content TEXT,
                vector_similarity FLOAT,
                text_score DOUBLE PRECISION,
                combined_score FLOAT
            ) AS $$
            BEGIN
                RETURN QUERY
                WITH vector_results AS (
                    SELECT
                        d.id,
                        d.title,
                        d.content,
                        1 - (d.embedding <=> query_embedding) as vector_similarity
                    FROM ai_data.documents d
                    WHERE 1 - (d.embedding <=> query_embedding) > similarity_threshold
                    ORDER BY d.embedding <=> query_embedding
                    LIMIT limit_count * 2
                ),
                text_results AS (
                    SELECT
                        d.id,
                        d.title,
                        d.content,
                        ts_rank(to_tsvector('english', d.title || ' ' || d.content), plainto_tsquery('english', query_text))::DOUBLE PRECISION as text_score
                    FROM ai_data.documents d
                    WHERE to_tsvector('english', d.title || ' ' || d.content) @@ plainto_tsquery('english', query_text)
                    ORDER BY ts_rank(to_tsvector('english', d.title || ' ' || d.content), plainto_tsquery('english', query_text)) DESC
                    LIMIT limit_count * 2
                )
                SELECT
                    COALESCE(vr.id, tr.id) as id,
                    COALESCE(vr.title, tr.title) as title,
                    COALESCE(vr.content, tr.content) as content,
                    COALESCE(vr.vector_similarity, 0.0) as vector_similarity,
                    COALESCE(tr.text_score, 0.0) as text_score,
                    (COALESCE(vr.vector_similarity, 0.0) * 0.7 + COALESCE(tr.text_score, 0.0) * 0.3) as combined_score
                FROM vector_results vr
                FULL OUTER JOIN text_results tr ON vr.id = tr.id
                ORDER BY combined_score DESC
                LIMIT limit_count;
            END;
            $$ LANGUAGE plpgsql;
          - |
            GRANT USAGE ON SCHEMA ai_data TO app;
            GRANT SELECT ON ALL TABLES IN SCHEMA ai_data TO app;
            GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA ai_data TO app;
            ALTER DEFAULT PRIVILEGES IN SCHEMA ai_data GRANT SELECT ON TABLES TO app;
            ALTER DEFAULT PRIVILEGES IN SCHEMA ai_data GRANT EXECUTE ON FUNCTIONS TO app;

# Image catalog for custom PostgreSQL image
catalog:
  enabled: true
  name: sojoner-catalog

# NodePort service (optional for external access)
nodePort:
  enabled: false
  port: 5432
  nodePort: null
  externalTrafficPolicy: Local
  labels: {}
  annotations: {}
